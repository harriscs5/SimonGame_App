let sequence = [];
let humanSequence = [];
let level = 0;

const startButton = document.querySelector('.js-start');
const info = document.querySelector('.js-info');
const heading = document.querySelector('.js-heading');
const tileContainer = document.querySelector('.js-container');

//comparing the sequences order entered to sequence generated by computer. != then game resets & gives failure alert message

function resetGame(text) {
  alert(text);
  sequence = [];
  level = 0;
  startButton.classList.remove('hidden');
  heading.textContent = 'Simon Says';
  info.classList.add('hidden');
  tileContainer.classList.add('unclickable');
}
//this function displays an alert and restarts the game


//humanTurn function indicates that the computer is finished with the round, and that itâ€™s time for the player to repeat the sequence:

function humanTurn(level) {
  tileContainer.classList.remove('unclickable');
  info.textContent = `Your turn: ${level} Tap${level > 1 ? 's' : ''}`;
} 

//enables playing by activating tiles on the screen in the right order
function activateTile(color) {
  const tile = document.querySelector(`[data-tile='${color}']`);
  const sound = document.querySelector(`[data-sound='${color}']`);

  tile.classList.add('activated');
  sound.play();

  setTimeout(() => {
    tile.classList.remove('activated');
  }, 300); // sound plays for 300 milliseconds
}

function playRound(nextSequence) {
  nextSequence.forEach((color, index) => {
    setTimeout(() => {
      activateTile(color);
    }, (index + 1) * 600); //new sequence activated every 600 milliseconds(ms) 
  });
}

function nextStep() {
  const tiles = ['red', 'green', 'blue', 'yellow'];
  const random = tiles[Math.floor(Math.random() * tiles.length)];

  return random;
}
//math.random gives random number, math.floor rounds up to next whole number
//titles.length ensures that the random value is between 0 - 3
//the value is added to the end of the nextSequence() array alongside any values from the previous round.


//each time nextRound() invoked, the level variable is incremented by 1 and next sequence is prepared  
function nextRound() {
  level += 1;

  tileContainer.classList.add('unclickable');
  info.textContent = 'Wait for the computer';
  heading.textContent = `Level ${level} of 20`;

  // unclickable class is added to the tile container when the round starts, and the contents of the info and heading elements are updated.


  // copies all the elements in the `sequence` array to `nextSequence`
  const nextSequence = [...sequence];
  nextSequence.push(nextStep());
  playRound(nextSequence);

  sequence = [...nextSequence];
  setTimeout(() => {
    humanTurn(level);
  }, level * 600 + 1000);
}
//setTimeout() causes artificial time delay humanTurn 1 seconds after last button in sequence is activated

function handleClick(tile) {
  const index = humanSequence.push(tile) - 1;
  const sound = document.querySelector(`[data-sound='${tile}']`);
  sound.play();

  const remainingTaps = sequence.length - humanSequence.length;

  if (humanSequence[index] !== sequence[index]) 
  {
    resetGame('Oops! you pressed the wrong tile, Try again');
    return;
  }

  if (humanSequence.length === sequence.length)
   {
    if (humanSequence.length === 20) {
      resetGame('Congrats! You completed all the levels');
      return
    } // the code that ends the game when user wins all levels

    humanSequence = [];
    info.textContent = 'You are on a roll! Keep going!';
    setTimeout(() => {
      nextRound();
    }, 1000);
    return;
  }

  info.textContent = `Your turn: ${remainingTaps} Tap${
    remainingTaps > 1 ? 's' : ''
  }`;
}
//handleClick function pushes the tile value to the humanSequence array and stores its index in the index variable. The corresponding sound for the button is played and the remaining steps in the sequence is calculated and updated on the screen.


function startGame() {
  startButton.classList.add('hidden');
  info.classList.remove('hidden');
  info.textContent = 'Wait for the computer';
  nextRound();
}

//Event listeners 
startButton.addEventListener('click', startGame);

tileContainer.addEventListener('click', event => {
  const { tile } = event.target.dataset;

  if (tile) handleClick(tile);
}); 
//value of data-tile on the element that was clicked is accessed and stored in the tile variable.




